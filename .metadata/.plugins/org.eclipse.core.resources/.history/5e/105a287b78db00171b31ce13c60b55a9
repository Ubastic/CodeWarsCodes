//Solution for https://www.codewars.com/kata/582c1092306063791c000c00/train/java

/**
 * 
 * change the code to allow a = 99 to check b = 100 (different radix)
 * 
 * @author USER
 *
 */
public class InfiniteDigitalString {

	public static long findPosition(final String s){
		
		for(int length = 1; length <= s.length(); length++)
			for(int lengthIndex = 0; lengthIndex < length; lengthIndex++){
				String a = "";
				for(int i = 0; i < length; i++){
					if(lengthIndex + i < s.length())
						a += Character.toString(s.charAt(lengthIndex + i));
					else
						a += "x";
				}
				//checks if a is a valid number
				if(isValidA(a)){
					boolean goToNextLengthIndex = false;
					
					//Check previous if previous exists
					if(lengthIndex != 0){
						String prev = "";
						//pad with x's
						for(int j = 0; j < length - lengthIndex; j++){
							prev += "x";
						}
						//add the prev string
						for(int k = 0; k < lengthIndex; k++){
							prev += Character.toString(s.charAt(k));
						}
						//if a has an x
						if(a.charAt(a.length()-1) == 'x'){
							long temp = fillInAndConsecutive(a, prev);
							if(temp == -1)
								goToNextLengthIndex = true;
							else
								return temp;
						}
						//if a doesn't have x but previous has x
						else if(!isConsecutive(prev,a))
							goToNextLengthIndex = true;
					}
					
					//iterate through string given the a to check if they are consecutive
					while(!goToNextLengthIndex){
						String curr = a;
						int strPos = lengthIndex + length;
						while(strPos + length < s.length()){
							String next = s.substring(strPos, strPos + length);
							if(!isConsecutive(curr, next)){
								goToNextLengthIndex = true;
								break;
							}
							curr = next;
							strPos += length;
						}
						//nothing left to check
						if(strPos == s.length() - 1){
							return calcPosition(a);
						}
						//check last string
						String last = "";
						for(int m = strPos; m < s.length(); m++)
							last += Character.toString(s.charAt(m));
						for(int n = last.length(); n <= length; n++)
							last += "x";
						if(isConsecutive(curr,last))
							return calcPosition(a);
						else
							goToNextLengthIndex = true;
					}
				}
			}
		return 0;
	}
	
	//this works
	public static long calcPosition(long index){
		long sum = 0;
		long checkAmt = 10;
		while(checkAmt < index){
			sum += 9 * (checkAmt / 10) * (Math.log10(checkAmt));
			checkAmt *= 10;
		}
		checkAmt /= 10;
		sum += (index - checkAmt) * Math.log10(checkAmt * 10);
		return sum;
	}
	
	//checks if a is a valid number (can't be 01 or 001 or 093, etc.)
	public static boolean isValidA(String a){
		if(a.charAt(0) == '0')
			return false;
		return true;
	}
	
	//checks if two numbers are consecutive
	//HAVE TO CHECK IF THIS WORKS
	public static boolean isConsecutive(String a, String b){
		//if number has an x
		int numA = Integer.parseInt(a);
		int tempNum = numA + 1;
		String checkNum = Integer.toString(tempNum);
		for(int i = 0; i < checkNum.length(); i++)
			if(checkNum.charAt(i) != b.charAt(i))
				return false;
		return true;
	}
	
	//checks prev and a (with x's) to see if they are consecutive
	public static long fillInAndConsecutive(String a, String b){
		//if matches return calcPosition(Integer.parseInt(a))
		//else return -1
	}

}
